import { RxFormGroup, RxFormArray, RxFormControl, RxwebValidators } from '@rxweb/reactive-form-validators';
import { __decorate, __metadata } from 'tslib';
import { Input, Directive, ElementRef, Renderer2, ComponentFactoryResolver, ViewContainerRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

function isNotMatched(jsonObject, compareObject) {
    let isModified = false;
    for (var columnName in compareObject) {
        if (Array.isArray(jsonObject[columnName])) {
            for (var i = 0; i < jsonObject[columnName].length; i++) {
                isModified = isNotMatched(jsonObject[columnName][i], compareObject[columnName][i]);
            }
        }
        else if (typeof jsonObject[columnName] == "object")
            isModified = isNotMatched(jsonObject[columnName], compareObject[columnName]);
        else
            isModified = !(jsonObject[columnName] == compareObject[columnName]);
        if (isModified)
            break;
    }
    return isModified;
}

class ValueChangeNotification {
    constructor() {
        this.attributeChangeSubscriptions = new Array();
    }
    onPropValueChanged(controlId, subscription, func) {
        this.attributeChangeSubscriptions.push({ controlId: controlId, names: subscription.names, props: subscription.props, func: func });
    }
    notifyValueChanged(name, value, oldValue, isProps = false) {
        if ((!isProps && this.isNotEqual(oldValue, value)) && this.onPropValueChanged) {
            let subscriptions = this.attributeChangeSubscriptions.filter(t => t.names.indexOf(name) != -1);
            subscriptions.forEach(subscribe => {
                if (subscribe.props && subscribe.props[name])
                    subscribe.func(subscribe.props[name]);
            });
        }
    }
    isNotEqual(leftValue, rightValue) {
        if (Array.isArray(leftValue) && Array.isArray(rightValue)) {
            let isNotEqual = leftValue.length != rightValue.length;
            if (!isNotEqual)
                for (var i = 0; i < leftValue.length; i++) {
                    isNotEqual = isNotMatched(leftValue[i], rightValue[i]);
                    if (isNotEqual)
                        break;
                }
            return isNotEqual;
        }
        return leftValue != rightValue;
    }
    destroy(controlId) {
        for (var i = 0; i < this.attributeChangeSubscriptions.length; i++) {
            if (this.attributeChangeSubscriptions[i].controlId == controlId) {
                this.attributeChangeSubscriptions.splice(i, 1);
                break;
            }
        }
    }
}

const FILTER = "filter";
const FUNCTION = "function";
const ERRORS = "errors";
class PropDescriptor extends ValueChangeNotification {
    checkFilterFunction() {
        let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), FILTER);
        this.isDefinedFilter = (descriptor && !descriptor.get && !descriptor.set && typeof this[FILTER] == FUNCTION);
    }
    overrideProp(props) {
        Object.keys(props).forEach(t => {
            Object.defineProperty(this, t, props[t]);
        });
    }
    defineProp(propName) {
        let value = this.props[propName];
        let oldValue = null;
        Object.defineProperty(this.props, propName, {
            get: () => { return value; },
            set: (v) => {
                value = v;
                this.notifyValueChanged(`props.${propName}`, value, oldValue, false);
                oldValue = value;
            }
        });
    }
    overrideProps() {
        ["disabled", "label", "placeholder", "hide", "description", "focus", "readonly", "class", "source"].forEach(t => {
            let descriptor = this.getDescriptor(t);
            let value = null;
            let oldValue = null;
            Object.defineProperty(this, t, {
                get: () => { return descriptor ? descriptor.get.call(this) : value; },
                set: (v) => {
                    value = v;
                    if (descriptor && descriptor.set)
                        descriptor.set.call(this, v);
                    super.notifyValueChanged(t, value, oldValue);
                    oldValue = v;
                }
            });
        });
    }
    overrideErrorsProp(formControl) {
        let value = formControl.errors;
        let errorMessage = '';
        let oldValue = formControl.errorMessage;
        Object.defineProperty(formControl, ERRORS, {
            get: () => { return value; },
            set: (v) => {
                value = v;
                errorMessage = formControl.errorMessage;
                this.notifyValueChanged(`errorMessage`, errorMessage || "", oldValue);
                oldValue = formControl.errorMessage;
            }
        });
        formControl[ERRORS] = formControl[ERRORS];
    }
    getDescriptor(propName) {
        let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), propName);
        if (!descriptor)
            descriptor = Object.getOwnPropertyDescriptor(this, propName);
        return descriptor;
    }
}

const FILE = 'file';
const RANGE = 'range';
const CHECKBOX = 'checkbox';
const BLANK = "";
const PROP = "prop";
const ATTR = "attr";
const EVENTS = "events";
const FOCUS = "focus";
const READONLY = "readonly";
const CLASS = "class";
const STYLE = "style";
const RADIO = "radio";
const STRING = "string";
const FUNCTION$1 = "function";
const SQUARE = "{";
const COLON = ":";
const CLICK = "click";
const INPUT = "input";
const TEXT = "text";
const CONTROL = 'control';
const BLUR = 'blur';
const SELECT = "select";
const TEXTAREA = "textarea";
const BOOLEAN = "boolean";
const NONE = "none";
const DISPLAY = "display";
const ADDITIONAL_CLASS = "additional-class";
const SELECT_MULTIPLE = "select-multiple";
const SOURCE = "source";
const ADVANCE = "advance";
const SQUARE_CONTROL = "[control]";
const SQUARE_LABEL = "[label]";
const SQUARE_SMALL = "[small]";
const SQUARE_ERROR = "[error]";
const FILTER$1 = "filter";
const INPUT_TEXT = "input-text";
const PREPEND_LEFT = "prepend-left";
const PREPEND_RIGHT = "prepend-right";
const PREPEND_BOTH = "prepend-both";
const CONDITIONAL_VALIDATOR = "conditionalValidator";
const INLINE = "inline";

class Linq {
    static extractArguments(splitTexts) {
        let expressionArguments = ["this"];
        if (splitTexts && splitTexts[0])
            splitTexts[0].split(",").forEach(t => expressionArguments.push(t.trim().replace("(", "").replace(")", "")));
        return expressionArguments;
    }
    static dynamicConfigParser(expressionString) {
        let controlNames = [];
        let expressionArguments = Linq.extractArguments(expressionString.match(/\(([^)]+)\)/g));
        let splitString = expressionString.replace(new RegExp(/\r?\n|\r|;/g), ' ').replace(/["%()\{}=\\?´`'#<>|,;:+-]+/g, " ").split(/ /g);
        if (expressionArguments.length > 3)
            expressionArguments.splice(expressionArguments.length - 1, 1);
        splitString.forEach((t, i) => {
            if (t) {
                if (t.includes("controlsConfig.")) {
                    let splitText = t.split("controlsConfig.");
                    if (splitText.length > 1)
                        controlNames.push(splitText[1].split(".")[0]);
                }
                else if (t.includes("controlsConfig["))
                    controlNames.push(splitString[i + 1]);
            }
        });
        return controlNames;
    }
}

class ControlState {
}
ControlState.controlId = 1;
ControlState.controls = {};
class NotificationState {
}
NotificationState.notificationId = 1;
NotificationState.notifications = {};

class BaseFormControlConfig extends PropDescriptor {
    constructor(configs, notificationId) {
        super();
        this.configs = configs;
        this.notificationId = notificationId;
        this._actionResult = {
            label: undefined,
            img: undefined,
            placeholder: undefined,
            source: [],
            filter: [],
            hide: false,
            description: undefined,
            disabled: false,
            focus: false,
            readonly: false,
            class: [],
            prependText: ''
        };
    }
    setNotification() {
        if (NotificationState.notifications[this.notificationId])
            if (!NotificationState.notifications[this.notificationId][this.config.name])
                NotificationState.notifications[this.notificationId][this.config.name] =
                    this.controlNotifications = { filter: [], disabled: [], label: [], description: [], hide: [], placeholder: [], readonly: [], focus: [], class: [] };
            else
                this.controlNotifications = NotificationState.notifications[this.notificationId][this.config.name];
        this.complete();
    }
    complete() {
        for (let action in this.controlNotifications) {
            let descriptor = this.getDescriptor(action);
            if ((descriptor && descriptor.get) || this.isDefinedFilter) {
                let stringFunction = this.isDefinedFilter ? String(this[FILTER$1]) : String(descriptor.get);
                let columnNames = Linq.dynamicConfigParser(stringFunction);
                columnNames.forEach(column => {
                    if (!NotificationState.notifications[this.notificationId][column])
                        NotificationState.notifications[this.notificationId][column] = { filter: [], disabled: [], label: [], description: [], hide: [], placeholder: [], readonly: [], focus: [], class: [] };
                    let controlNotifications = NotificationState.notifications[this.notificationId][column];
                    controlNotifications[action].push(this.config.name);
                });
            }
        }
        this.overrideProps();
        this.updateActionValue();
    }
    refresh(actionName) {
        for (var columnName in this.controlNotifications) {
            if (this.controlNotifications[columnName].length > 0)
                this.controlNotifications[columnName].forEach(x => {
                    if (columnName == FILTER$1)
                        this.configs[x].value = null;
                    if (x != this.config.name)
                        this.configs[x].refresh(columnName);
                    else
                        this.setActionValue(columnName);
                });
        }
        if (actionName)
            this.setActionValue(actionName);
    }
    setActionValue(actionName) {
        if (actionName == FILTER$1 && this.isDefinedFilter) {
            this[FILTER$1].call(this);
        }
        else
            this[actionName == FILTER$1 ? SOURCE : actionName] = this[actionName];
    }
    updateActionValue() {
        ["disabled", "label", "img", "placeholder", "hide", "description", "focus", "readonly", "class", "filter", "source"].forEach(key => {
            switch (key) {
                case FILTER$1:
                    if (this.isDefinedFilter && key == FILTER$1)
                        this[FILTER$1]();
                    if (this.config.filter)
                        this[FILTER$1] = this.config.filter;
                    break;
                case SOURCE:
                    if (this.config[key])
                        this[key] = this.config[key];
                    if (key == SOURCE && !this.source)
                        this[key] = [];
                    break;
                default:
                    if (this.config.ui && this.config.ui[key])
                        this[key] = this.config.ui[key];
                    else
                        this[key == FILTER$1 ? SOURCE : key] = this._actionResult[key];
                    break;
            }
        });
    }
}

const dynamicContainer = new (class {
    constructor() {
        this.components = [];
        this.overrideProps = {};
    }
    registerComponent(name, target) {
        let componentContainer = this.components.filter(component => component.instance == target)[0];
        if (!componentContainer)
            this.components.push({ instance: target, name: name });
    }
    registerOverrideProp(props) {
        if (props)
            Object.keys(props).forEach(t => this.overrideProps[t] = props[t]);
    }
    getOverrideProp(name) {
        return this.overrideProps[name];
    }
    getComponent(name) {
        return this.components.filter(component => component.name == name)[0];
    }
})();

class FormControlConfig extends BaseFormControlConfig {
    constructor(fieldConfig, controlsConfig, notificationId) {
        super(controlsConfig, notificationId);
        this.controlsConfig = controlsConfig;
        this.overrides = {};
        this.config = fieldConfig;
        this.overrideProperty();
        this.value = fieldConfig.value;
        super.checkFilterFunction();
        this.props = this.config.props || Object.create({});
        this.setNotification();
    }
    overrideProperty() {
        if (this.config.overrideProps) {
            this.config.overrideProps.forEach(t => {
                let propInfo = dynamicContainer.getOverrideProp(t);
                this.overrideProp(propInfo);
            });
        }
    }
    set formControl(value) {
        this._formControl = value;
        setTimeout(() => this.overrideErrorsProp(this._formControl), 10);
    }
    get formControl() {
        return this._formControl;
    }
    get errorMessage() {
        return this.formControl.errorMessage;
    }
    get prependText() {
        return this.config.ui ? this.config.ui.prependText : '';
    }
}
class ControlConfig extends FormControlConfig {
    constructor(fieldConfig, controlsConfig) {
        super(fieldConfig, controlsConfig, 0);
    }
}

function getInstance(model, objectArguments) {
    let classInstance = Object.create(model.prototype);
    try {
        model.apply(classInstance, objectArguments);
    }
    catch (ex) {
        ///resolution of issue https://github.com/rxweb/rxweb/issues/188
        classInstance = Reflect.construct(model, objectArguments);
    }
    return classInstance;
}

class ApplicationUtil {
    static getRootFormGroup(control) {
        if (control.parent) {
            return this.getRootFormGroup(control.parent);
        }
        return control;
    }
    static isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }
}

const ARRAY = "array";
class RxDynamicFormBuilder {
    formGroup(fields, dynamicFormConfig) {
        let notificationId = NotificationState.notificationId++;
        NotificationState.notifications[notificationId] = {};
        this.formConfiguration = dynamicFormConfig || {};
        let entityObject = {};
        let formFieldConfigs = new Array();
        let modelConfig = {};
        let formGroup = new RxFormGroup({}, entityObject, {}, undefined);
        fields.forEach((x, i) => {
            if (x.type == ARRAY) {
                this.createFormArray(modelConfig, x, ApplicationUtil.getRootFormGroup(formGroup), entityObject, notificationId);
            }
            else {
                let splitName = x.name.split('.');
                let name = x.name;
                if (splitName.length > 1) {
                    if (!entityObject[splitName[0]]) {
                        entityObject[splitName[0]] = {};
                        formGroup.addControl(splitName[0], new RxFormGroup({}, entityObject[splitName[0]], {}, undefined));
                        formGroup = formGroup.controls[splitName[0]];
                    }
                    else if (formGroup.controls[splitName[0]] != undefined && formGroup.controls[splitName[0]] instanceof RxFormGroup)
                        formGroup = formGroup.controls[splitName[0]];
                    name = splitName[1];
                }
                else
                    formGroup = ApplicationUtil.getRootFormGroup(formGroup);
                let modelInstance = this.getDynamicModelInstance(x, modelConfig, entityObject, name, notificationId);
                formGroup.addControl(name, modelInstance.formControl);
                formFieldConfigs.push(modelInstance);
            }
        });
        if (this.formConfiguration.additionalConfig)
            this.formConfiguration.additionalConfig.forEach(t => this.getModelInstance(t, modelConfig, notificationId));
        let rootFormGroup = ApplicationUtil.getRootFormGroup(formGroup);
        rootFormGroup["model"] = undefined;
        return {
            controlsConfig: modelConfig,
            formGroup: rootFormGroup
        };
    }
    createFormArray(modelConfig, field, formGroup, entityObject, notificationId) {
        modelConfig[field.name] = [];
        entityObject[field.name] = [];
        let formArray = new RxFormArray(entityObject[field.name], []);
        if (field.controlConfigs) {
            if (field.rows)
                field.rows.forEach(row => {
                    formArray.controls.push(this.createDynamicFormGroup(field, modelConfig[field.name], this.getRefObject(entityObject[field.name]), row, notificationId));
                });
            if (field.minimumRepeatCount && field.minimumRepeatCount > 0) {
                let countLeft = field.minimumRepeatCount - (formArray.controls.length);
                for (var i = 0; i < countLeft; i++)
                    formArray.controls.push(this.createDynamicFormGroup(field, modelConfig[field.name], this.getRefObject(entityObject[field.name]), { fields: [] }, notificationId));
            }
            this.addTwoProp(modelConfig[field.name], field, entityObject[field.name], formArray, notificationId);
            formGroup.addControl(field.name, formArray);
        }
    }
    getRefObject(entityObject) {
        let jObject = {};
        entityObject.push(jObject);
        return jObject;
    }
    addTwoProp(modelConfig, x, entityObject, formArray, notificationId) {
        modelConfig.__proto__.addItem = () => {
            formArray.controls.push(this.createDynamicFormGroup(x, modelConfig, this.getRefObject(entityObject), { fields: [] }, notificationId));
        };
        modelConfig.__proto__.removeItem = (index) => {
            formArray.removeAt(index);
            modelConfig.splice(index, 1);
        };
    }
    createDynamicFormGroup(x, modelConfig, entityObject, row, notificationId) {
        let nestedFormGroup = new RxFormGroup({}, entityObject, {}, undefined);
        let jObject = {};
        modelConfig.push(jObject);
        Object.keys(x.controlConfigs).forEach(key => {
            let field = row.fields.filter(x => x.name == key)[0];
            let formControlConfig = Object.assign({}, x.controlConfigs[key], { name: key });
            if (field)
                formControlConfig = Object.assign({}, formControlConfig, field);
            let modelInstance = this.getDynamicModelInstance(formControlConfig, jObject, entityObject, key, notificationId);
            nestedFormGroup.addControl(key, modelInstance.formControl);
        });
        return nestedFormGroup;
    }
    getModelInstance(x, modelConfig, notificationId) {
        let configModel = (x.modelName) && this.formConfiguration && this.formConfiguration.controlConfigModels ? this.formConfiguration.controlConfigModels.filter((y) => y.modelName == x.modelName)[0] : undefined;
        let modelArguments = [x, modelConfig, notificationId];
        let model = undefined;
        if (configModel) {
            model = configModel.model;
            if (configModel.arguments)
                configModel.arguments.forEach(t => modelArguments.push(t));
        }
        else
            model = FormControlConfig;
        let modelInstance = getInstance(model, modelArguments);
        modelConfig[x.name] = modelInstance;
        return modelInstance;
    }
    getDynamicModelInstance(x, modelConfig, entityObject, name, notificationId) {
        let modelInstance = this.getModelInstance(x, modelConfig, notificationId);
        let validators = [];
        let asyncValidators = [];
        if (x.validators)
            this.validatorBindings(validators, x.validators);
        if (modelInstance.validator)
            validators.push(modelInstance.validator.bind(modelInstance));
        if (modelInstance.asyncValidator)
            asyncValidators.push(modelInstance.asyncValidator.bind(modelInstance));
        if (modelInstance)
            entityObject[x.name] = x.value;
        let baseObject = {};
        baseObject[x.name] = x.value;
        entityObject[x.name] = x.value;
        modelInstance.formControl = new RxFormControl(x.value, validators, asyncValidators, entityObject, baseObject, name, undefined);
        return modelInstance;
    }
    validatorBindings(validations, validationConfig) {
        for (var column in RxwebValidators) {
            if (validationConfig[column]) {
                validations.push(RxwebValidators[column](validationConfig[column]));
            }
        }
        return validations;
    }
}

const commonAttributes = {
    placeholder: ':placeholder',
    readonly: ':readonly',
    class: ':class',
    name: '{config.name'
};
const commonEvents = {
    focus: ':focus',
    input: 'true',
    blur: 'blur'
};
const ɵ0 = function (item, index) {
    return ['div', ['input', [{
                    attr: Object.assign({ type: '{config.type' }, commonAttributes, { value: item[this.config.valuePropName || 'value'], checked: item[this.config.valuePropName || 'value'] == this.value, disabled: item.disabled ? item.disabled : ':disabled' }),
                    events: commonEvents,
                    overrideProp: (index == 0)
                }],
            'label', [{ prop: { innerText: item[this.config.textPropName || 'text'] } }]]];
};
const checkBoxAndRadioDesign = ['div', [{ source: true }, {
            for: {
                source: ɵ0
            }
        }
    ]];
const configUiText = { innerText: ':props.text' };
const classAttribute = { class: ':class', style: { display: ":hide" } };
const ɵ1 = function (item) {
    return ['label', [{
                attr: Object.assign({ type: '{config.type' }, commonAttributes, { value: item[this.config.valuePropName || 'value'] }),
                events: commonEvents
            }],
        'label', [{ prop: { innerText: item[this.config.textPropName || 'text'] } }]];
}, ɵ2 = function (item) {
    return ['option', [
            {
                prop: { innerText: item[this.config.textPropName || 'text'] }, attr: {
                    value: item[this.config.valuePropName || 'value'],
                    selected: Array.isArray(this.value) ? this.value.filter(x => item[this.config.valuePropName || 'value'] == x)[0] != undefined : item[this.config.valuePropName || 'value'] == this.value,
                    disabled: item.disabled
                }
            }
        ]];
};
const DYNAMIC_ELEMENT_DESIGN_TREE = {
    p: ['p', [{ prop: configUiText, attr: classAttribute }]],
    h1: ['h1', [{ prop: configUiText, attr: classAttribute }]],
    h2: ['h2', [{ prop: configUiText, attr: classAttribute }]],
    h3: ['h3', [{ prop: configUiText, attr: classAttribute }]],
    h4: ['h4', [{ prop: configUiText, attr: classAttribute }]],
    h5: ['h5', [{ prop: configUiText, attr: classAttribute }]],
    h6: ['h6', [{ prop: configUiText, attr: classAttribute }]],
    a: ['a', [{ attr: Object.assign({ href: '{config.href' }, classAttribute), prop: configUiText }]],
    hr: ['hr', [{ attr: commonAttributes }]],
    strong: ['strong', [{ prop: configUiText, attr: classAttribute }]],
    span: ['span', [{ prop: configUiText, attr: classAttribute }]],
    img: ['img', [{ prop: { src: ':img' }, attr: Object.assign({ style: { display: ":img" } }, classAttribute) }]],
    label: ['label', [{ prop: { innerText: ':label' }, attr: Object.assign({ style: { display: ":label" } }, classAttribute) }]],
    small: ['small', [{ prop: { innerText: ':description' }, attr: Object.assign({ style: { display: ":description" } }, classAttribute) }]],
    input: ['input', [{
                attr: Object.assign({ type: '{config.type' }, commonAttributes, { disabled: ':disabled' }),
                events: commonEvents,
            }]],
    error: [`span`, [{ prop: { innerText: ':errorMessage' }, attr: Object.assign({ style: { display: ":errorMessage" } }, commonAttributes) }]],
    div: ['div', [{ attr: classAttribute }]],
    card: ['div', [{ attr: classAttribute }]],
    'card-header': ['div', [{ attr: classAttribute, prop: configUiText }]],
    'card-body': ['div', [{ attr: classAttribute }]],
    buttonGroup: ['div', [{
                for: {
                    source: ɵ1
                }
            }
        ]
    ],
    'prepend-left': ["div", [
            "div", [
                "div", [{ prop: { innerText: '{config.ui.prependText.left' } }]
            ],
            '[input-text]'
        ]],
    'prepend-right': ["div", [
            '[input-text]',
            "div", [
                "div", [{ prop: { innerText: '{config.ui.prependText.right' } }]
            ],
        ]],
    'prepend-both': ["div", [
            "div", [
                "div", [{ prop: { innerText: '{config.ui.prependText.left' } }]
            ],
            '[input-text]',
            "div", [
                "div", [{ prop: { innerText: '{config.ui.prependText.right' } }]
            ],
        ]],
    textarea: ['textarea', [{ attr: Object.assign({ rows: '{config.ui.rows', cols: '{config.ui.cols' }, commonAttributes), events: commonEvents }]],
    radio: checkBoxAndRadioDesign,
    'checkbox': checkBoxAndRadioDesign,
    select: ['select', [{
                attr: {
                    multiple: '{config.multiselect',
                },
                events: commonEvents,
                source: true
            },
            'option', [{ prop: { innerText: `:placeholder` }, attr: { value: '', style: { display: ":placeholder" } } }],
            {
                for: {
                    source: ɵ2
                }
            }
        ]],
    button: ['button', [{ attr: Object.assign({}, commonAttributes, { name: '{config.name', type: '{config.type' }), events: { click: '{config.events.click' }, prop: { innerText: ':props.text' } }]],
    alert: ['div', [{ attr: commonAttributes }]],
    viewMode: {
        basic: ['div', [{
                    attr: {
                        style: { display: ":hide" }
                    }
                },
                '[label]',
                '[control]',
                '[error]',
                '[small]'
            ]],
        horizontal: ['div', [{
                    attr: {
                        style: { display: ":hide" }
                    }
                },
                '[label]',
                'div', ['[control]', '[error]', '[small]']
            ]],
        inline: [],
        advance: ['div', [
                'div', [{
                        attr: {
                            style: { display: ":hide" }
                        }
                    },
                    '[img]', '[label]', '[control]', '[error]', '[small]']
            ]]
    }
};

const BOOSTRAP_CLASS_CONFIG = {
    defaultControl: 'form-control',
    fileControl: 'form-control-file',
    readOnlyPlainText: 'form-control-plaintext',
    rangeControl: 'form-control-range',
    checkBoxAndRadioControl: 'form-check-input',
    checkboxAndRadioControlInline: 'form-check-inline',
    controlValid: 'is-valid',
    controlInvalid: 'is-invalid',
    validMessage: 'valid-feedback',
    invalidMessage: 'invalid-feedback',
};
const PREPEND_TEXT_CLASS_PATH = {
    class: ['input-group-prepend'],
    child: {
        0: { class: ['input-group-text'] }
    }
};
const INPUT_GROUP = ['input-group'];
const BOOTSTRAP_DESIGN_CONFIG = {
    elementClassPath: {
        "prepend-left": {
            class: INPUT_GROUP,
            child: {
                0: PREPEND_TEXT_CLASS_PATH
            }
        },
        "prepend-right": {
            class: INPUT_GROUP,
            child: {
                1: PREPEND_TEXT_CLASS_PATH
            }
        },
        "prepend-both": {
            class: INPUT_GROUP,
            child: {
                0: PREPEND_TEXT_CLASS_PATH,
                2: PREPEND_TEXT_CLASS_PATH
            }
        },
        input: { class: [inputElementClassProvider, invalidClass], listenerProps: [":errorMessage"] },
        checkbox: {
            class: [], child: {
                0: {
                    class: ['form-check', inLineRadioAndCheckbox],
                    child: { 0: { class: ['form-check-input'] }, 1: { class: ['form-check-label'] } }
                }
            }
        },
        radio: {
            class: [], child: {
                0: {
                    class: ['form-check', inLineRadioAndCheckbox],
                    child: { 0: { class: ['form-check-input'] }, 1: { class: ['form-check-label'] } }
                }
            }
        },
        'error': { class: [function () { return !((this.formControl.validator || this.formControl.asyncValidator) && this.formControl.errorMessage) ? "" : BOOSTRAP_CLASS_CONFIG.invalidMessage; }], listenerProps: [":errorMessage"] },
        button: { class: ['btn'] },
        alert: { class: ['alert'] },
        card: { class: ['card'] },
        'card-header': { class: ['card-header'] },
        'card-body': { class: ['card-body'] },
        viewMode: {
            basic: { class: ['form-group'] },
            horizontal: {
                class: ['form-group', 'row'],
                child: {
                    0: { class: [function () { return this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.horizontal && this.config.ui.viewMode.horizontal.label ? this.config.ui.viewMode.horizontal.label : ''; }] },
                    1: {
                        class: [function () { return this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.horizontal && this.config.ui.viewMode.horizontal.div ? this.config.ui.viewMode.horizontal.div : ''; }],
                    }
                }
            },
            inline: {
                class: [], child: {}
            },
            advance: {
                class: ['form-row', function () { return this.config && this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.advance && this.config.ui.viewMode.advance.root_div ? this.config.ui.viewMode.advance.root_div : ''; }],
                child: {
                    0: {
                        class: ['form-group', function () { return this.config && this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.advance && this.config.ui.viewMode.advance.div ? this.config.ui.viewMode.advance.div : ''; }],
                        child: {
                            0: { class: [function () { return this.config && this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.advance && this.config.ui.viewMode.advance.label ? this.config.ui.viewMode.advance.label : ''; }] },
                            2: { class: [function () { return this.config && this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.advance && this.config.ui.viewMode.advance.error ? this.config.ui.viewMode.advance.error : ''; }] },
                            3: { class: [function () { return this.config.ui && this.config.ui.viewMode && this.config.ui.viewMode.advance && this.config.ui.viewMode.advance.small ? this.config.ui.viewMode.advance.small : ''; }] }
                        }
                    }
                }
            }
        },
        small: { class: ['form-text'] },
        textarea: { class: [BOOSTRAP_CLASS_CONFIG.defaultControl, invalidClass], listenerProps: [":errorMessage"] },
        select: { class: [BOOSTRAP_CLASS_CONFIG.defaultControl, invalidClass], listenerProps: [":errorMessage"] }
    }
};
function inputElementClassProvider() {
    let elementClass = '';
    if (!this.readonly || (this.readonly && !this.isPlainTextMode))
        switch (this.config.type) {
            case FILE:
                elementClass = BOOSTRAP_CLASS_CONFIG.fileControl;
                break;
            case RANGE:
                elementClass = BOOSTRAP_CLASS_CONFIG.rangeControl;
                break;
            case RADIO:
            case CHECKBOX:
                elementClass = BLANK;
                break;
            default:
                elementClass = BOOSTRAP_CLASS_CONFIG.defaultControl;
                break;
        }
    else if (this.readonly && this.isPlainTextMode)
        elementClass = BOOSTRAP_CLASS_CONFIG.readOnlyPlainText;
    return elementClass;
}
function inLineRadioAndCheckbox() {
    return this.config && this.config.inline ? ['form-check-inline'] : [];
}
function invalidClass() {
    let invalidClass = ((this.formControl.validator || this.formControl.asyncValidator) && this.formControl.errorMessage) ? BOOSTRAP_CLASS_CONFIG.controlInvalid : '';
    return invalidClass;
}

function objectPropValue(key, valueObject) {
    let jObject = undefined;
    let splitTexts = key.split('.');
    for (var column of splitTexts) {
        if (!jObject)
            jObject = valueObject;
        if (jObject)
            jObject = jObject[column];
        else
            break;
    }
    return jObject;
}

const PROPS = ":props.";
const GLOBAL_MATCH = "g";
const DOT = ".";
class BaseObjectAccessor {
    constructor(dynamicNodeConfig) {
        this.dynamicNodeConfig = dynamicNodeConfig;
        this.subscribeProps = {
            names: [], props: {}
        };
        this.controlConfig = this.dynamicNodeConfig.controlConfig;
    }
    getPropName(text) {
        if (text[0] == COLON || (text[0] == SQUARE)) {
            return text.replace(new RegExp(COLON, GLOBAL_MATCH), BLANK).replace(new RegExp(SQUARE, GLOBAL_MATCH), BLANK);
        }
        return text;
    }
    getValue(text) {
        if (typeof text == STRING && ((text[0] == COLON) || (text[0] == SQUARE))) {
            text = text.replace(new RegExp(COLON, GLOBAL_MATCH), BLANK).replace(new RegExp(SQUARE, GLOBAL_MATCH), BLANK);
            return objectPropValue(text, this.controlConfig);
        }
        return text;
    }
    setPropSubscription(propName, type, attributeName, valuePropName = '', parentPropName = '') {
        if (propName.startsWith(PROPS))
            this.defineProp(propName);
        let prop = this.getPropName(propName);
        if (!this.subscribeProps.props[prop])
            this.subscribeProps.props[prop] = {};
        if (!this.subscribeProps.props[prop][type])
            this.subscribeProps.props[prop][type] = {};
        if (parentPropName) {
            this.subscribeProps.props[prop][type][parentPropName] = {};
            this.subscribeProps.props[prop][type][parentPropName][attributeName] = (valuePropName) ? valuePropName : propName;
        }
        else
            this.subscribeProps.props[prop][type][attributeName] = (valuePropName) ? valuePropName : propName;
        if (this.subscribeProps.names.indexOf(prop) == -1)
            this.subscribeProps.names.push(prop);
    }
    isSubscribeProp(propName) {
        return (typeof propName == STRING && (propName[0] == COLON));
    }
    defineProp(propName) {
        let splitText = propName.split(DOT);
        if (splitText.length > 1) {
            let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.controlConfig.props), splitText[1]);
            if (!descriptor)
                this.controlConfig.defineProp(splitText[1]);
        }
    }
}

class ComponentView {
    constructor(_component, _viewContainerRef, _componentFactoryResolver, formControlConfig, dynamicFormBuildConfig) {
        this.formControlConfig = formControlConfig;
        this.dynamicFormBuildConfig = dynamicFormBuildConfig;
        this.component = _component;
        this.viewContainerRef = _viewContainerRef;
        this.componentFactoryResolver = _componentFactoryResolver;
    }
    create() {
        let componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.component);
        this.componentRef = this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, this.viewContainerRef.parentInjector);
        this.setParams(this.componentRef.instance);
    }
    setParams(instance) {
        if (this.formControlConfig.inputs) {
            let propNames = Object.getOwnPropertyNames(this.formControlConfig.inputs);
            for (let propName of propNames)
                this.overridePropAndSetValue(instance, propName, this.formControlConfig.inputs);
        }
        instance["controlConfig"] = this.formControlConfig;
        instance["dynamicFormBuildConfig"] = this.dynamicFormBuildConfig;
    }
    overridePropAndSetValue(instance, propName, inputs) {
        let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(inputs), propName);
        let value = '';
        if (!descriptor) {
            value = inputs[propName];
            delete inputs[propName];
        }
        Object.defineProperty(inputs, propName, {
            get() { return (descriptor) ? descriptor.get() : value; },
            set(v) { instance[propName] = v; (descriptor) ? descriptor.set.call(inputs, v) : value = v; }
        });
        instance[propName] = descriptor ? descriptor.get.call(inputs) : value;
    }
    rootNode() {
        return this.componentRef.hostView.rootNodes[0];
    }
    getComponentRef() {
        return this.componentRef;
    }
    destroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = undefined;
        }
    }
}

class ElementAccessor extends BaseObjectAccessor {
    constructor(dynamicNodeConfig) {
        super(dynamicNodeConfig);
        this.checkedCheckbox = (value, element) => (value) ? (this.controlConfig.config.multiselect) ? value.filter(t => element.value == t)[0] != undefined : element.value == value : false;
        this.checkedRadio = (value, element) => (value) ? value == element.value : false;
    }
    createNodeElement(parentElement, name) {
        this.element = name.startsWith("#") ? this.createComponentView(this.dynamicNodeConfig.controlConfig) : this.dynamicNodeConfig.renderer.createElement(name);
        this.dynamicNodeConfig.renderer.appendChild(parentElement, this.element);
    }
    createComponentView(controlConfig) {
        let container = dynamicContainer.getComponent(controlConfig.config.type.replace("#", ""));
        if (container) {
            this.componentView = new ComponentView(container.instance, this.dynamicNodeConfig.viewContainerRef, this.dynamicNodeConfig.componentFactoryResolver, controlConfig, this.dynamicNodeConfig.dynamicFormBuildConfig);
            this.componentView.create();
            return this.componentView.rootNode();
        }
    }
    removeChildren(element) {
        if (element.firstElementChild) {
            this.removeChildren(element.firstElementChild);
        }
        let controlId = element.getAttribute("data-rxwebid");
        if (controlId && ControlState.controls[controlId]) {
            ControlState.controls[controlId].destroy();
            delete ControlState.controls[controlId];
        }
    }
    setControlConfigValue(targetElement) {
        let value = targetElement.value === "" ? null : targetElement.value;
        switch (targetElement.type) {
            case FILE:
                this.controlConfig.formControl.setValue(targetElement.files);
                this.controlConfig.value = targetElement.files;
                break;
            case CHECKBOX:
                this.setCheckboxValue(targetElement);
                break;
            case SELECT_MULTIPLE:
                let values = [];
                for (let option of this.element.options)
                    if (option.selected && option.value)
                        values.push(option.value);
                this.controlConfig.value = values;
                break;
            default:
                this.controlConfig.formControl.setValue(value);
                this.controlConfig.value = value;
                break;
        }
    }
    resetElementValue(value) {
        switch (this.element.type) {
            case CHECKBOX:
            case RADIO:
                var elements = document.querySelectorAll(`[name='${this.controlConfig.config.name}']`);
                for (var i = 0; i < elements.length; i++) {
                    elements[i].checked = this.element.type == CHECKBOX ? this.checkedCheckbox(value, elements[i]) : this.checkedRadio(value, elements[i]);
                }
                break;
            case SELECT_MULTIPLE:
                for (let option of this.element.options) {
                    option.selected = (value) ? value.filter(t => t == option.value)[0] != undefined : false;
                }
                break;
            default:
                this.element.value = value;
        }
    }
    setCheckboxValue(targetElement) {
        let value = (this.controlConfig.config.multiselect) ? this.controlConfig.value || [] : targetElement.value;
        if (targetElement.checked)
            (this.controlConfig.config.multiselect) ? value.push(targetElement.value) : null;
        else
            (this.controlConfig.config.multiselect) ? value.splice(value.indexOf(targetElement.value), 1) : value = null;
        this.controlConfig.formControl.setValue(value);
        this.controlConfig.value = value;
    }
}

class ElementEventProcessor extends ElementAccessor {
    constructor(dynamicNodeConfig) {
        super(dynamicNodeConfig);
        this.dynamicNodeConfig = dynamicNodeConfig;
    }
    bindEvents(events, isSubscribe) {
        Object.keys(events).forEach(eventName => {
            switch (eventName) {
                case FOCUS:
                    this.setFocus(this.getValue(events[eventName]));
                    break;
                case SELECT:
                case INPUT:
                    this.setInput();
                    break;
                case BLUR:
                    this.setBlur();
                    break;
                case CLICK:
                    this.setClick(this.getValue(events[eventName]));
                    break;
            }
            if (isSubscribe && this.isSubscribeProp(events[eventName]))
                this.setPropSubscription(this.getPropName(events[eventName]), EVENTS, eventName);
        });
    }
    setClick(functionName) {
        this.element.onclick = () => {
            if (this.controlConfig[functionName])
                this.controlConfig[functionName].call(this.controlConfig);
        };
    }
    setFocus(value) {
        if (value && this.element.focus)
            setTimeout(t => { this.element.focus(); }, 1000);
    }
    setBlur() {
        let listen = this.dynamicNodeConfig.renderer.listen(this.element, BLUR, () => {
            this.dynamicNodeConfig.controlConfig.formControl.markAsTouched();
        });
        this.eventListeners.push(listen);
    }
    setInput() {
        let listen = this.dynamicNodeConfig.renderer.listen(this.element, INPUT, (v) => {
            let isPassed = true;
            if (this.controlConfig.hooks && this.controlConfig.hooks.preValue) {
                isPassed = this.controlConfig.hooks.preValue.call(this.controlConfig, v.target.value);
                if (!isPassed) {
                    this.controlConfig.formControl.patchValue(this.controlConfig.formControl.value);
                    this.resetElementValue(this.controlConfig.formControl.value);
                }
            }
            if (isPassed) {
                this.setControlConfigValue(v.target);
                if (this.controlConfig.hooks && this.controlConfig.hooks.postValue)
                    this.controlConfig.hooks.postValue.call(this.controlConfig);
                this.controlConfig.formControl.markAsDirty();
            }
            if (this.conditionalValidator)
                this.conditionalValidator(this.controlConfig.formControl);
        });
        this.eventListeners.push(listen);
        setTimeout(() => {
            if (this.controlConfig.formControl[CONDITIONAL_VALIDATOR]) {
                this.conditionalValidator = this.controlConfig.formControl[CONDITIONAL_VALIDATOR];
                delete this.controlConfig.formControl[CONDITIONAL_VALIDATOR];
            }
        }, 50);
    }
}

class ElementPropsAccessor extends ElementEventProcessor {
    constructor(dynamicNodeConfig) {
        super(dynamicNodeConfig);
        this.oldAdditionalClasses = [];
        this.oldClasses = [];
    }
    bindAttribute(attr, isSubscribe) {
        Object.keys(attr).forEach(attributeName => {
            let value = (attributeName !== STYLE) ? this.getValue(attr[attributeName]) : attr[attributeName];
            switch (attributeName) {
                case ADDITIONAL_CLASS:
                case CLASS:
                    this.setClass(value, attributeName);
                    break;
                case STYLE:
                    Object.keys(attr[attributeName]).forEach(x => {
                        let value = this.getValue(attr[attributeName][x]);
                        this.setStyleProp(x, value);
                        if (isSubscribe && this.isSubscribeProp(attr[attributeName][x]))
                            this.setPropSubscription(attr[attributeName][x], ATTR, x, '', STYLE);
                    });
                    break;
                default:
                    this.addOrRemoveAttribute(attributeName, value, attr[attributeName] === "");
                    break;
            }
            if (isSubscribe && attributeName !== STYLE && this.isSubscribeProp(attr[attributeName]))
                this.setPropSubscription(attr[attributeName], ATTR, attributeName);
        });
    }
    bindProp(prop, isSubscribe) {
        Object.keys(prop).forEach(propName => {
            let value = this.getValue(prop[propName]);
            this.setProperty(propName, (value !== undefined && value !== null && value !== false) ? value : "");
            if (isSubscribe && this.isSubscribeProp(prop[propName]))
                this.setPropSubscription(prop[propName], PROP, propName);
        });
    }
    setClass(classes, type) {
        classes = this.getClassNames(type == ADDITIONAL_CLASS ? this.dynamicNodeConfig.additionalClasses.class : classes);
        type == ADDITIONAL_CLASS ? this.addOrRemoveClasses(this.oldAdditionalClasses, false) : this.addOrRemoveClasses(this.oldClasses, false);
        this.addOrRemoveClasses(classes);
        switch (type) {
            case ADDITIONAL_CLASS:
                this.oldAdditionalClasses = classes;
                break;
            case CLASS:
                this.oldClasses = classes;
                break;
        }
    }
    setStyleProp(propName, value) {
        switch (propName) {
            case DISPLAY:
                value = (typeof value == BOOLEAN || value === undefined) ? value : !(value);
                value = (value) ? NONE : BLANK;
                break;
        }
        this.addOrRemoveStyle(propName, value);
    }
    setProperty(propertyName, value) {
        this.dynamicNodeConfig.renderer.setProperty(this.element, propertyName, value);
    }
    addOrRemoveClasses(classes, isAdd = true) {
        if (isAdd)
            classes.forEach(t => this.dynamicNodeConfig.renderer.addClass(this.element, t));
        else
            classes.forEach(t => this.dynamicNodeConfig.renderer.removeClass(this.element, t));
    }
    addOrRemoveStyle(styleName, value) {
        if (value)
            this.dynamicNodeConfig.renderer.setStyle(this.element, styleName, value);
        else
            this.dynamicNodeConfig.renderer.removeStyle(this.element, styleName);
    }
    addOrRemoveAttribute(attributeName, value, isBlank) {
        if (value || isBlank)
            this.dynamicNodeConfig.renderer.setAttribute(this.element, attributeName, value);
        else
            this.dynamicNodeConfig.renderer.removeAttribute(this.element, attributeName);
    }
    getClassNames(classes) {
        let elementClasses = [];
        if (classes)
            classes.forEach(t => {
                if (typeof t == STRING)
                    elementClasses.push(t);
                else if (typeof t == FUNCTION$1) {
                    let elementClass = t.call(this.controlConfig);
                    if (elementClass && !Array.isArray(elementClass))
                        elementClasses.push(elementClass);
                    else if (Array.isArray(elementClass))
                        elementClass.forEach(x => elementClasses.push(x));
                }
            });
        return elementClasses;
    }
}

const VALUE = "value";
class OverrideObjectProp extends ElementPropsAccessor {
    constructor(dynamicNodeConfig) { super(dynamicNodeConfig); }
    overrideValueProp() {
        let descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.controlConfig), VALUE);
        let value = this.controlConfig.value;
        let oldValue = null;
        Object.defineProperty(this.controlConfig, VALUE, {
            get: () => { return descriptor ? descriptor.get.call(this.controlConfig) : value; },
            set: (v) => {
                value = v;
                if (this.controlConfig.formControl.value != v) {
                    this.controlConfig.formControl.setValue(v);
                    this.resetElementValue(v);
                    this.controlConfig.value = v;
                }
                else {
                    this.controlConfig.notifyValueChanged(VALUE, v, oldValue);
                    if (descriptor)
                        descriptor.set.call(this.controlConfig, v);
                    this.controlConfig.refresh();
                }
                this.controlConfig.config.value = v;
                oldValue = v;
            }
        });
        this.overrideFormControlProp();
        if (this.controlConfig.formControl.value)
            setTimeout(() => { this.resetElementValue(this.controlConfig.formControl.value); }, 50);
    }
    overrideFormControlProp() {
        let value = this.controlConfig.formControl.value;
        Object.defineProperty(this.controlConfig.formControl, VALUE, {
            get: () => { return value; },
            set: (v) => {
                value = v;
                var t = setTimeout(() => {
                    if (value != this.controlConfig.value) {
                        this.controlConfig.value = value;
                        this.resetElementValue(value);
                    }
                }, 50);
            }
        });
    }
}

class DomManipulation extends OverrideObjectProp {
    constructor(parentNode, elementName, dynamicNodeConfig) {
        super(dynamicNodeConfig);
        this.isComponentView = false;
        this.subscribers = [];
        this.elementIndex = 0;
        this.eventListeners = [];
        this.actionListeners = {};
        this.elementClasses = [];
        this.nodeName = elementName;
        super.createNodeElement(parentNode, elementName);
        this.bindAdditionalClasses();
        this.controlId = ControlState.controlId = ControlState.controlId + 1;
        ControlState.controls[this.controlId] = this;
        this.addOrRemoveAttribute("data-rxwebid", this.controlId, false);
    }
    parseObject(jObject, isSubscribe) {
        this.domConfig = jObject;
        this.process(jObject, isSubscribe);
        this.overrideProp(isSubscribe);
        this.subscribeValueChange();
    }
    subscribeValueChange() {
        if (Object.keys(this.subscribeProps).length > 0)
            this.controlConfig.onPropValueChanged(this.controlId, this.subscribeProps, (x, y) => {
                this.process(x, false);
            });
    }
    process(jObject, isSubscribe) {
        Object.keys(jObject).forEach(propName => {
            switch (propName) {
                case PROP:
                    this.bindProp(jObject[propName], isSubscribe);
                    break;
                case ATTR:
                    this.bindAttribute(jObject[propName], isSubscribe);
                    break;
                case EVENTS:
                    this.bindEvents(jObject[propName], isSubscribe);
                    break;
                case SOURCE:
                    if (!isSubscribe) {
                        while (this.element.firstElementChild)
                            this.removeChildren(this.element.firstElementChild);
                        this.dynamicNodeConfig.controlConfigProcessor.createChildrens(this.dynamicNodeConfig.collections, this, this.controlConfig, this.dynamicNodeConfig.additionalClasses, false);
                    }
                    else
                        this.setPropSubscription(SOURCE, SOURCE, SOURCE);
                    break;
            }
        });
    }
    overrideProp(isSubscribe) {
        switch (this.nodeName) {
            case INPUT:
            case SELECT:
            case TEXTAREA:
                if (this.domConfig.overrideProp == undefined || this.domConfig.overrideProp)
                    this.overrideValueProp();
                this.setPropSubscription(READONLY, ATTR, ADDITIONAL_CLASS, ADDITIONAL_CLASS);
                if (this.controlConfig && this.controlConfig.config && this.controlConfig.config.additionalConfig)
                    this.process(this.controlConfig.config.additionalConfig, isSubscribe);
                break;
        }
    }
    bindAdditionalClasses() {
        let additionalClasses = this.dynamicNodeConfig.additionalClasses;
        if (additionalClasses && additionalClasses.class) {
            this.setClass(additionalClasses.class, ADDITIONAL_CLASS);
            if (additionalClasses.listenerProps)
                additionalClasses.listenerProps.forEach(t => this.setPropSubscription(t, ATTR, ADDITIONAL_CLASS, ADDITIONAL_CLASS));
        }
    }
    destroy() {
        let eventCount = this.eventListeners.length;
        for (var i = 0; i < eventCount; i++) {
            this.eventListeners[0]();
            this.eventListeners.splice(0, 1);
        }
        this.eventListeners = [];
        this.element.onClick = null;
        if (this.componentView)
            this.componentView.destroy();
        else
            this.element.parentElement.removeChild(this.element);
        this.controlConfig.destroy(this.controlId);
    }
}

class ControlConfigProcessor {
    constructor(element, renderer, componentFactoryResolver, viewContainerRef) {
        this.element = element;
        this.renderer = renderer;
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.isBuild = false;
    }
    set viewMode(value) {
        this._viewMode = value;
        if (this.isBuild)
            this.build();
    }
    get viewMode() {
        return this._viewMode;
    }
    get currentViewMode() {
        return DYNAMIC_ELEMENT_DESIGN_TREE.viewMode[this.viewMode];
    }
    getView(name, controlConfig) {
        if (this.viewMode == INLINE)
            name = this.getName(name, controlConfig, true);
        return DYNAMIC_ELEMENT_DESIGN_TREE[name];
    }
    get viewClassPath() {
        return BOOTSTRAP_DESIGN_CONFIG.elementClassPath.viewMode[this.viewMode];
    }
    build() {
        this.uiBindings.forEach(controlConfigName => {
            this.designForm(controlConfigName, this.element, this.currentViewMode[0], this.currentViewMode[1], BOOTSTRAP_DESIGN_CONFIG.elementClassPath.viewMode[this.viewMode]);
        });
    }
    designForm(controlConfigName, element, viewRoot, viewChild, classPath, childrenControlConfig) {
        let controlConfig = childrenControlConfig || this.getControlConfig(controlConfigName);
        if (controlConfig) {
            if (this.viewMode != INLINE && controlConfig && !controlConfig.config.skipDefaultView)
                this.createElement(viewRoot, viewChild, element, controlConfig, classPath);
            else {
                let currentView = this.getView(controlConfig.config.type, controlConfig);
                if (currentView)
                    this.createElement(currentView[0], currentView[1], element, controlConfig, this.getClassPath(controlConfig.config.type, controlConfig, this._viewMode == INLINE));
                else
                    this.createDomManipulation(controlConfig.config.type, [], element, controlConfig, [], true);
            }
        }
        else if (this.viewMode == ADVANCE && Array.isArray(controlConfigName)) {
            let config = new ControlConfig({}, {});
            let domManipulation = this.createElement(this.currentViewMode[0], [], element, config, BOOTSTRAP_DESIGN_CONFIG.elementClassPath.viewMode[this.viewMode]);
            controlConfigName.forEach(t => {
                this.designForm(t, domManipulation.element, this.currentViewMode[1][0], this.currentViewMode[1][1], BOOTSTRAP_DESIGN_CONFIG.elementClassPath.viewMode[this.viewMode].child["0"]);
            });
        }
    }
    createElement(elementName, collections, parentElement, controlConfig, elementClassPath) {
        if (!elementName.startsWith("#")) {
            elementClassPath = elementClassPath ? elementClassPath : {};
            let domManipulation = this.createDomManipulation(elementName, collections, parentElement, controlConfig, elementClassPath);
            this.createChildrens(collections, domManipulation, controlConfig, elementClassPath);
            if (controlConfig.config && controlConfig.config.childrens && controlConfig.config.childrens.length > 0) {
                controlConfig.config.childrens.forEach((t, i) => {
                    let childrenControlConfig = undefined;
                    if (!(typeof t == STRING) && !Array.isArray(t))
                        childrenControlConfig = new ControlConfig(Object.assign({}, t, { skipDefaultView: true }), {});
                    this.designForm(t, domManipulation.element, this.currentViewMode[0], this.currentViewMode[1], BOOTSTRAP_DESIGN_CONFIG.elementClassPath.viewMode[this.viewMode], childrenControlConfig);
                });
            }
            return domManipulation;
        }
        else
            this.createDomManipulation(elementName, collections, parentElement, controlConfig, elementClassPath, true); //this.createComponentView(controlConfig, parentElement);
    }
    createDomManipulation(elementName, collections, parentElement, controlConfig, elementClassPath, isComponentView = false) {
        let dynamicNodeConfig = {
            controlConfig: controlConfig, additionalClasses: elementClassPath, renderer: this.renderer, collections: collections, controlConfigProcessor: this,
            viewContainerRef: isComponentView ? this.viewContainerRef : undefined,
            componentFactoryResolver: isComponentView ? this.componentFactoryResolver : undefined,
            dynamicFormBuildConfig: this.dynamicFormBuildConfig
        };
        return new DomManipulation(parentElement, elementName, dynamicNodeConfig);
    }
    createChildrens(collections, domManipulation, controlConfig, elementClassPath, isSubscribe = true) {
        let elementCount = 0;
        let childElementsClassConfig = elementClassPath.child ? elementClassPath.child : {};
        for (var i = 0; i < collections.length; i++) {
            let collection = collections[i];
            if (!ApplicationUtil.isObject(collection)) {
                if (this.isCreateElement(collections[i], controlConfig)) {
                    if (collection == SQUARE_CONTROL && controlConfig.config.type == undefined && controlConfig.config.childControlConfigs) {
                        controlConfig.config.childControlConfigs.forEach(x => {
                            let childControlConfig = this.getControlConfig(x);
                            this.createChildNodes(collections, childControlConfig, childElementsClassConfig, elementCount, i, domManipulation);
                        });
                    }
                    else {
                        if (collection == SQUARE_CONTROL && controlConfig.config.type.startsWith("#"))
                            this.createDomManipulation(controlConfig.config.type, [], domManipulation.element, controlConfig, [], true);
                        else {
                            let isIncrease = this.createChildNodes(collections, controlConfig, childElementsClassConfig, elementCount, i, domManipulation);
                            if (isIncrease)
                                i = i + 1;
                        }
                    }
                }
                elementCount++;
            }
            else {
                if (collection.for)
                    this.runForCollection(collection, domManipulation, controlConfig, elementClassPath);
                if (isSubscribe)
                    domManipulation.parseObject(collections[i], isSubscribe);
            }
        }
    }
    createChildNodes(collections, controlConfig, childElementsClassConfig, elementCount, i, domManipulation) {
        let isNextCollection = false;
        let nextCollection = this.getCollection(collections[i], controlConfig);
        let childClasses = this.getAdditionalClasses(collections[i], childElementsClassConfig, elementCount, controlConfig);
        if (!nextCollection) {
            nextCollection = [collections[i], collections[i + 1]];
            isNextCollection = true;
        }
        this.createElement(nextCollection[0], nextCollection[1], domManipulation.element, controlConfig, childClasses);
        return isNextCollection;
    }
    runForCollection(collection, domManipulation, controlConfig, elementClassPath) {
        Object.keys(collection.for).forEach(t => {
            let source = objectPropValue(t, controlConfig);
            source.forEach((x, index) => {
                let item = collection.for[t].call(controlConfig, x, index);
                this.createChildrens(item, domManipulation, controlConfig, elementClassPath);
            });
        });
    }
    getAdditionalClasses(name, childClasses, index, controlConfig) {
        name = this.getName(name, controlConfig);
        let additionalClasses = BOOTSTRAP_DESIGN_CONFIG.elementClassPath[name];
        let childrenClasses = childClasses[index] ? childClasses[index] : {
            class: []
        };
        if (additionalClasses) {
            if (childrenClasses.class)
                additionalClasses = { class: additionalClasses.class.concat(childrenClasses.class), listenerProps: additionalClasses.listenerProps, child: additionalClasses.child };
            return additionalClasses;
        }
        return childrenClasses;
    }
    getCollection(name, controlConfig) {
        if (name[0] == "[") {
            name = this.getName(name, controlConfig);
            return DYNAMIC_ELEMENT_DESIGN_TREE[name];
        }
        return undefined;
    }
    getControlName(name) {
        let controlName = '';
        switch (name) {
            case "number":
            case "color":
            case "date":
            case "email":
            case "password":
            case "tel":
            case "time":
            case "url":
            case "color":
            case RANGE:
            case FILE:
            case TEXT:
                controlName = INPUT;
                break;
            default:
                controlName = name;
        }
        return controlName;
    }
    getControlConfig(name) {
        return this.dynamicFormBuildConfig.controlsConfig[name];
    }
    getName(name, controlConfig, isInline = false) {
        name = name.replace(new RegExp(/\[/g), '').replace(new RegExp(/\]/g), '');
        name = (name == CONTROL || isInline) ? this.getControlName(controlConfig.config.type) : name;
        switch (name) {
            case INPUT:
                name = this.prependControl(name, controlConfig);
                break;
            case INPUT_TEXT:
                name = INPUT;
                break;
        }
        return name;
    }
    prependControl(name, controlConfig) {
        if (controlConfig.config.ui && controlConfig.config.ui.prependText && controlConfig.config.ui.prependText.right && controlConfig.config.ui.prependText.left)
            name = PREPEND_BOTH;
        else if (name == INPUT && controlConfig.config.ui && controlConfig.config.ui.prependText && controlConfig.config.ui.prependText.left)
            name = PREPEND_LEFT;
        else if (name == INPUT && controlConfig.config.ui && controlConfig.config.ui.prependText && controlConfig.config.ui.prependText.right)
            name = PREPEND_RIGHT;
        return name;
    }
    isCreateElement(collection, controlConfig) {
        let isCreate = true;
        switch (collection) {
            case "[img]":
                isCreate = controlConfig.img != undefined;
            case SQUARE_LABEL:
                isCreate = controlConfig.label != undefined;
                break;
            case SQUARE_SMALL:
                isCreate = controlConfig.description != undefined;
                break;
            case SQUARE_ERROR:
                isCreate = controlConfig.formControl != undefined && (controlConfig.formControl.validator != undefined || controlConfig.formControl.asyncValidator != undefined);
                break;
        }
        return isCreate;
    }
    getClassPath(name, controlConfig, isInline) {
        if (this.viewMode == INLINE)
            name = this.getName(name, controlConfig, isInline);
        return BOOTSTRAP_DESIGN_CONFIG.elementClassPath[name];
    }
}
__decorate([
    Input('rxwebDynamicForm'),
    __metadata("design:type", Object)
], ControlConfigProcessor.prototype, "dynamicFormBuildConfig", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ControlConfigProcessor.prototype, "viewMode", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ControlConfigProcessor.prototype, "uiBindings", void 0);

let RxDynamicFormDirective = class RxDynamicFormDirective extends ControlConfigProcessor {
    constructor(elementRef, renderer, componentFactoryResolver, viewContainerRef) {
        super(elementRef.nativeElement, renderer, componentFactoryResolver, viewContainerRef);
    }
    ngOnInit() {
        this.build();
    }
    removeChildren(element) {
        while (element.firstElementChild)
            this.removeChildren(element.firstElementChild);
        let controlId = element.getAttribute("data-rxwebid");
        if (controlId && ControlState.controls[controlId]) {
            ControlState.controls[controlId].destroy();
            delete ControlState.controls[controlId];
        }
    }
    ngOnDestroy() {
        if (this.element)
            this.removeChildren(this.element);
    }
};
RxDynamicFormDirective = __decorate([
    Directive({
        selector: '[rxwebDynamicForm]'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, ComponentFactoryResolver, ViewContainerRef])
], RxDynamicFormDirective);

var RxReactiveDynamicFormsModule_1;
let RxReactiveDynamicFormsModule = RxReactiveDynamicFormsModule_1 = class RxReactiveDynamicFormsModule {
    static forRoot() { return { ngModule: RxReactiveDynamicFormsModule_1, providers: [] }; }
};
RxReactiveDynamicFormsModule = RxReactiveDynamicFormsModule_1 = __decorate([
    NgModule({
        declarations: [RxDynamicFormDirective],
        imports: [CommonModule],
        providers: [RxDynamicFormBuilder],
        exports: [RxDynamicFormDirective]
    })
], RxReactiveDynamicFormsModule);

function dynamicComponent(name) {
    return function (target) {
        dynamicContainer.registerComponent(name, target);
    };
}

function overrideProps(props) {
    return function (target) {
        dynamicContainer.registerOverrideProp(props);
    };
}

class AbstractControlConfig {
    set controlConfig(value) {
        this._controlConfig = value;
    }
    get controlConfig() {
        return this._controlConfig;
    }
    set dynamicFormBuildConfig(value) {
        this._dynamicFormBuildConfig = value;
    }
    get dynamicFormBuildConfig() {
        return this._dynamicFormBuildConfig;
    }
    addItem() {
        this.dynamicFormBuildConfig.controlsConfig[this.controlConfig.config.controlConfigName]["addItem"]();
    }
    removeItem(index) {
        this.dynamicFormBuildConfig.controlsConfig[this.controlConfig.config.controlConfigName]["removeItem"](index);
    }
}
__decorate([
    Input(),
    __metadata("design:type", FormControlConfig),
    __metadata("design:paramtypes", [FormControlConfig])
], AbstractControlConfig.prototype, "controlConfig", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AbstractControlConfig.prototype, "dynamicFormBuildConfig", null);

export { AbstractControlConfig, BOOSTRAP_CLASS_CONFIG, BOOTSTRAP_DESIGN_CONFIG, ControlConfig, DYNAMIC_ELEMENT_DESIGN_TREE, FormControlConfig, RxDynamicFormBuilder, RxReactiveDynamicFormsModule, dynamicComponent, overrideProps, ɵ0, ɵ1, ɵ2, RxDynamicFormDirective as ɵa, ControlConfigProcessor as ɵb, BaseFormControlConfig as ɵc, PropDescriptor as ɵd, ValueChangeNotification as ɵe };
//# sourceMappingURL=rxweb-reactive-dynamic-forms.js.map
